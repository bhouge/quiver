<!doctype html>
<html>
<head>
<meta charset="UTF-8">
<title>QUIVER, POP, AND DISSOLVE: THREE ESSAYS IN GASTROMORPHOLOGY</title>
<style>
	body { font: 24px Helvetica, Arial; }
	button {
		-webkit-appearance: none;
		padding: 25px 5px;
		text-align: center;
		width: 90%;
		font-size: 64px;
		font-weight: bold;
	}
	.sliders {
    margin: auto;
    width: 50%;
    padding: 10px;
}
</style>
</head>
<body>
<h1>Quiver, Pop, and Dissolve: Three Essays in Gastromorphology</h1>
<h2>by Ben Houge and Jozef Youssef of Kitchen Theory</h2>

<p>
This project explores some of the different ways in which a meal can be considered as a time-based experience.
There is the succession of courses, the entropy of each dish over time (flavors meld, temperatures equalize), 
the rhythms of each bite, and the evolution and finish of flavor in the mouth.
The term gastromorphology may be used to describe a meal as a function of time.
</p>

<div id="controlButtons">
First Course:
<button id="course1" class="off">LOADING...</button>
<br><br>
Second Course:
<button id="course2" class="off">LOADING...</button>
<br><br>
Third Course:
<button id="course3" class="off">LOADING...</button>
</div>

<h3>
As you receive each new course, press the corresponding button below to trigger the musical accompaniment.
Turn your phone upside down to help the sound propagate and tap the screen periodically 
to keep it from going to sleep during the performance.
Please ensure that your volume is turned up and that your phone is not in silent mode.
Chrome or Firefox are the recommended browsers on Android devices.
This web page will also work on a laptop (in which case inverting the device is not recommended).
</h3>

<script src="/socket.io/socket.io.js"></script>
<script src="scripts/MIDIInstrument.js"></script>
<script src="scripts/IntermittentSound.js"></script>
<script src="scripts/Plunk.js"></script>
<script src="scripts/Evolve.js"></script>

<script type="text/javascript">

var socket = io();
socket.on('control message', function(msg){
	console.log("control message received: " + msg);
	if (msg != "panic") {
		var msgArray = msg.split('/');
		var lastPart = msgArray[msgArray.length-1].split(' ');
		if (msgArray.length >= 2) {
			if (lastPart[0] == 'command' && lastPart.length >= 2) {
				//kind of horrible idea for testing, simulating multiple devices to hear average timings...
				for (var i = 0; i < 1; i++) {
					//10 is the radix for decimal
					commandReceived(parseInt(lastPart[1], 10));
				}
			} else if (msgArray[msgArray.length-2] == 'slider' && lastPart.length >= 2) {
				var sliderIntValue = parseInt(lastPart[1], 10);
				var sliderFloatValue = parseFloat(lastPart[1], 10);
				switch (parseInt(lastPart[0], 10)) {
					case 0:
						console.log('slider 0 value: ' + sliderFloatValue);
						minVol = sliderFloatValue;
						break;
					case 1:
						console.log('slider 1 value: ' + sliderFloatValue);
						maxVol = sliderFloatValue;
						break;
					case 2:
						console.log('slider 2 value: ' + sliderFloatValue);
						minChirpPause = maxChirpLimit * sliderFloatValue;
						console.log('setting min chirp pause to ' + minChirpPause + ' ms.');
						break;
					case 3:
						console.log('slider 3 value: ' + sliderFloatValue);
						maxChirpPause = maxChirpLimit * sliderFloatValue;
						console.log('setting max chirp pause to ' + maxChirpPause + ' ms.');
						break;
					case 4:
						console.log('slider 4 value: ' + sliderFloatValue);
						minVolleyPause = maxVolleyLimit * sliderFloatValue;
						console.log('setting min chirp pause to ' + minVolleyPause + ' ms.');
						break;
					case 5:
						console.log('slider 5 value: ' + sliderFloatValue);
						maxVolleyPause = maxVolleyLimit * sliderFloatValue;
						console.log('setting max chirp pause to ' + maxVolleyPause + ' ms.');
						break;
					case 6:
						console.log('slider 6 value: ' + sliderIntValue);
						minChirps = sliderIntValue;
						break;
					case 7:
						console.log('slider 7 value: ' + sliderIntValue);
						maxChirps = sliderIntValue;
						break;
					default:
						console.log('Not a valid slider.');
						break;
				}
			} else {
				console.log ('Perhaps you have a malformed command message on your hands.');
			}
		}
	} else {
		stopEverything();
	}
});
socket.on('get type', function(msg){
	//console.log("client's secret message is " + msg);
	socket.emit('i am', "listener");
});
socket.on('sending audio', function(msg){
	console.log('this many audio files to receive: ' + msg);
	//alert('this many audio files: ' + msg);
	audioFilesToReceive = msg;
});
socket.on('audio', function(msg){
    console.log('audio received!');
    audioCtx.decodeAudioData(msg.buffer, function(buffer) {
    	audioBuffers[msg.index] = buffer;
    	console.log('buffer ' + msg.index + ' loaded');
    	audioFilesToReceive--;
    	if (audioFilesToReceive <= 0) {
    		console.log('all buffers loaded');
    		buffersAreLoaded = true;
    		initializeInstruments();
    		for (var i = 0; i < numberOfButtons; i++) {
    			var courseButton = document.getElementById('course' + (i + 1));
    			courseButton.innerHTML = 'LISTEN';
    		}
    	}
      }, 
      function(error) {
          console.error('decodeAudioData error', error);
      });
});

var timerID;
var minVol = 0.7;
var maxVol = 0.8;
//min limits are 0, units are ms
var maxChirpLimit = 10000;
var maxVolleyLimit = 10000;
var minChirpPause = 0.1 * maxChirpLimit;
var maxChirpPause = 0.25 * maxChirpLimit;
var minVolleyPause = 0.45 * maxVolleyLimit;
var maxVolleyPause = 0.75 * maxVolleyLimit;
var minChirps = 2;
var maxChirps = 5;
var chirpsRemaining = 0;
var birdVariations = 0;

var audioFilesToReceive = 0;

var numberOfButtons = 3;

var piano;
var nyatiti;
var vibes;


function playSound(index) {
	var source = audioCtx.createBufferSource();
	source.buffer = audioBuffers[index];
	gainNode.gain.value = Math.random() * (maxVol - minVol) + minVol;
	//gainNode.gain.value = Math.random();
	source.connect(gainNode);
    source.start(audioCtx.currentTime);
}


//gotta rethink this fo sho
var listenButtonEnabled = true;
var isChirping = false;
//var listenButton = document.getElementById('listen');

var course1Button = document.getElementById('course1');
var course2Button = document.getElementById('course2');
var course3Button = document.getElementById('course3');

course1Button.onclick = course1ButtonPressed;
course2Button.onclick = course2ButtonPressed;
course3Button.onclick = course3ButtonPressed;

/*
var buttons = document.getElementById("controlButtons");

for (var i = 0; i < numberOfButtons; i++) {
	var button = document.createElement("button");
	button.setAttribute("class", "off");
	button.setAttribute("id", "course" + i + 1);
	button.innerHTML = 'LOADING...';
	button.onclick = function() {
		if (buffersAreLoaded) {
			if (!isChirping) {
				chirpsRemaining = Math.floor(Math.random() * (1 + maxChirps - minChirps)) + minChirps;
				chirp(i);
				isChirping = true;
				this.innerHTML = 'STOP LISTENING';
			} else {
				window.clearTimeout(timerID);
				isChirping = false;
				this.innerHTML = 'LISTEN';
			}
		}
	};
	var buttonDescriptor = document.createTextNode("Course " + i + ":"); 
	var br = document.createElement("br");
	//evidently you can only append an element once? therefore I am creating two br elements
	var br2 = document.createElement("br");
	buttons.appendChild(buttonDescriptor); 
	buttons.appendChild(br);
	buttons.appendChild(button);
	if (i < numberOfButtons - 1) {
		buttons.appendChild(br2);
	}
	
	
	button.setAttribute("disabled", true);
	
	button.onclick = function () {
		var button = this;
		var index = button.id.slice(4);
		if (button.className == "off") {
			buttonActivated(index);
		} else {
			buttonDeactivated(index);
		}
	}
	
	buttons.appendChild(button);
	if (i==2 || i==6 || i==8 || i==14 || i==19) {
		var br = document.createElement("br");
        buttons.appendChild(br);
	}
	
}
 */

var course1Music = { 'isPlaying' : false };
var course2Music = { 'isPlaying' : false };
var course3Music = { 'isPlaying' : false };
 
function course1ButtonPressed() {
	if (buffersAreLoaded) {
		if (!course1Music.isPlaying) {
			//chirpsRemaining = Math.floor(Math.random() * (1 + maxChirps - minChirps)) + minChirps;
			var instrument = Math.floor(Math.random() * 2);
			if (instrument == 1) {
				course1Music = new Plunk(piano, 120., 4, 0, 3, 28, 28, course1MusicFinished);
			} else {
				course1Music = new Plunk(nyatiti, 120., 4, 0, 3, 28, 28, course1MusicFinished);
			}
			
			course1Music.connect(gainNode);
			course1Music.play();
			//isChirping = true;
			course1Button.innerHTML = 'STOP LISTENING';
		} else {
			//window.clearTimeout(timerID);
			course1Music.stop();
			//isChirping = false;
			course1Button.innerHTML = 'LISTEN';
		}
	}
}


function course2ButtonPressed() {
	if (buffersAreLoaded) {
		if (!course2Music.isPlaying) {
			//chirpsRemaining = Math.floor(Math.random() * (1 + maxChirps - minChirps)) + minChirps;
			course2Music = new Evolve([piano, nyatiti], 0.1, 0.1, 28, 28, course2MusicFinished);
			course2Music.connect(gainNode);
			//course2Music.playNote(2.2, 1., 1., 0.5);
			course2Music.play();
			//isChirping = true;
			course2Button.innerHTML = 'STOP LISTENING';
		} else {
			//window.clearTimeout(timerID);
			course2Music.stop();
			//isChirping = false;
			course2Button.innerHTML = 'LISTEN';
		}
	}
}

function course3ButtonPressed() {
	if (buffersAreLoaded) {
		if (!course3Music.isPlaying) {
			//chirpsRemaining = Math.floor(Math.random() * (1 + maxChirps - minChirps)) + minChirps;
			course3Music = new IntermittentSound(audioBuffers[3], 0.145, 0.5, 10, 15, 0.5, 0.9, 0.1, 2.0, [[0,0]], false, course3MusicFinished);
			course3Music.connect(gainNode);
			course3Music.play();
			//isChirping = true;
			course3Button.innerHTML = 'STOP LISTENING';
		} else {
			//window.clearTimeout(timerID);
			course3Music.stop();
			//isChirping = false;
			course3Button.innerHTML = 'LISTEN';
		}
	}
}

function course1MusicFinished() {
	course1Button.innerHTML = 'LISTEN';
}

function course2MusicFinished() {
	course2Button.innerHTML = 'LISTEN';
}

function course3MusicFinished() {
	course3Button.innerHTML = 'LISTEN';
}

function chirp() {
	var bufferToPlay;
	if (listenButtonEnabled && audioBuffers.length > 0) {
		//hopefully this little check will catch the case when all buffers might not yet have been received,
		//since they arrive asynchronously
		//and hopefully we are making sure that the button will not be enabled until at least one buffer has been received.
		do {
			bufferToPlay = Math.floor(Math.random() * audioBuffers.length);
		} while (!audioBuffers[bufferToPlay]);
	}
	playSound(bufferToPlay);
	chirpsRemaining--;
	console.log('chirpsRemaining: ' + chirpsRemaining);
	var pauseDur;
	if (chirpsRemaining > 0) {
		pauseDur = Math.random() * (maxChirpPause - minChirpPause) + minChirpPause;
	} else {
		pauseDur = Math.random() * (maxVolleyPause - minVolleyPause) + minVolleyPause;
		console.log('chirpsRemaining is 0 or less, so picking new volley time of ' + pauseDur);
		var randomNumber = Math.random();
		//console.log('randomNumber: ' + randomNumber);
		//console.log('minChirps: ' + minChirps + '; maxChirps: ' + maxChirps);
		//console.log('maxChirps - minChirps: ' + (maxChirps - minChirps));
		//console.log('1 + maxChirps - minChirps: ' + (1 + maxChirps - minChirps));
		//console.log('Math.random() * (1 + maxChirps - minChirps): ' + (randomNumber * (1 + maxChirps - minChirps)));
		//console.log('Math.random() * (1 + maxChirps - minChirps) + minChirps: ' + (randomNumber * (1 + maxChirps - minChirps) + minChirps));
		//console.log('Math.floor(Math.random() * (1 + maxChirps - minChirps)) + minChirps: ' + (Math.floor(randomNumber * (1 + maxChirps - minChirps)) + minChirps));
		chirpsRemaining = Math.floor(randomNumber * (1 + maxChirps - minChirps)) + minChirps;
		console.log('new chirpsRemaining: ' + chirpsRemaining);
	}
	//add length of sample
	pauseDur += audioBuffers[bufferToPlay].duration * 1000.0;
	timerID = window.setTimeout(chirp, pauseDur);
}

function stopEverything() {
	//not sure we need to implement this for Oxford...
}

function commandReceived(commandID) {
	console.log('command: ' + commandID);
		switch (commandID) {
		case 0:	
			console.log('zero');
			var chord = [72, 76, 79, 83];
			for (var i = 0; i < chord.length; i++) {
				vibes.playNote(0, chord[i], 0.25, 3., 0.);
			}
			break;
		case 1:
			console.log('one');
			var chord = [60, 67, 76];
			for (var i = 0; i < chord.length; i++) {
				vibes.playNote(0, chord[i], 0.25, 3., 0.);
			}
			break;
		case 2:
			console.log('two');
			var chord = [62, 71, 77];
			for (var i = 0; i < chord.length; i++) {
				vibes.playNote(0, chord[i], 0.25, 3., 0.);
			}
			break;
		case 3:
			var chord = [64, 74, 79];
			for (var i = 0; i < chord.length; i++) {
				vibes.playNote(0, chord[i], 0.15, 4., 0.);
			}
			break;
		case 4:
			var chord = [66, 69, 72];
			for (var i = 0; i < chord.length; i++) {
				vibes.playNote(0, chord[i], 0.15, 4., 0.);
			}
			break;
		case 5:
			var chord = [66, 73, 75];
			for (var i = 0; i < chord.length; i++) {
				vibes.playNote(0, chord[i], 0.15, 4., 0.);
			}
			break;
		case 6:
			var chord = [76];
			for (var i = 0; i < chord.length; i++) {
				vibes.playNote(0, chord[i], 0.15, 4., 0.);
			}
			break;
	}
}

function initializeInstruments() {
	//options include (bigger to smaller)
	//21/20 (40/21)
	//33/32 (64/33)
	//81/80 (160/81)

	
	//baseFreq 698.456463 Hz is MIDI note 77 (a high F)
	piano = new MIDIInstrument(audioBuffers[3], 698.456463, 0.01, 0.1);
	piano.retuningMap = [1/1, 33/32, 9/8, 32/27, 5/4, 4/3, 40/27, 3/2, 8/5, 12/7, 16/9, 64/33];
	piano.basePitchForRetuning = 0;
	piano.connect(gainNode);
	//baseFreq 186Hz is MIDI note 54.093589 (a little sharp of F# below middle C)
	nyatiti = new MIDIInstrument(audioBuffers[2], 186., 0.01, 0.5);
	nyatiti.retuningMap = piano.retuningMap;
	nyatiti.basePitchForRetuning = 0;
	nyatiti.connect(gainNode);
	//baseFreq 523.251131 Hz is MIDI note 72 (C above middle C, not sure why wave file is mislabeled)
	vibes = new MIDIInstrument(audioBuffers[0], 523.251131, 0.01, 0.5);
	vibes.retuningMap = piano.retuningMap;
	vibes.basePitchForRetuning = 0;
	vibes.connect(gainNode);
}

//setting up our audio context and creating our master gain
var AudioContext = window.AudioContext || window.webkitAudioContext;
var audioCtx = new AudioContext();

var gainNode = audioCtx.createGain();
gainNode.connect(audioCtx.destination);
gainNode.gain.value = 1.0;

var audioBuffers = [];
var buffersAreLoaded = false;

</script>

</body>
</html>